@typeparam TItem where TItem : class, new()
@using Table.Models
@using Table.Components

<CascadingValue Value="this">
    @ChildContent
</CascadingValue>

<div class="@DataGridStyles.GridContainer">
    <table class="@DataGridStyles.CustomDatagrid">
        <thead>
            <tr>
                <th class="@DataGridStyles.RowDragHeader @(AllowRowReorder ? string.Empty : DataGridStyles.Hidden)"></th>
                @foreach (var column in Columns)
                {
                    var isSortable = !AllowRowReorder && column.Sortable;
                    <th class="@(isSortable ? DataGridStyles.Sortable : string.Empty)"
                        @onclick="() => SortByColumn(column)">
                        @column.HeaderText
                        @if (isSortable)
                        {
                            <span class="@DataGridStyles.SortIcon @GetSortClass(column)"></span>
                        }
                    </th>
                }
                <th class="@DataGridStyles.ActionsHeader">Actions</th>
            </tr>
        </thead>
        <tbody>
            @for (var index = 0; index < Items.Count; index++)
            {
                var rowIndex = index;
                var item = Items[rowIndex];
                <tr class="@GetRowClass(item) @(DraggedRowIndex == rowIndex ? DataGridStyles.Dragging : string.Empty)"
                    @ondrop="() => OnRowDrop(rowIndex)"
                    @ondragover:preventDefault
                    @ondrop:preventDefault>
                    <td class="@DataGridStyles.RowDragHandle @(AllowRowReorder && !IsEditing(item) ? string.Empty : DataGridStyles.Hidden)"
                        draggable="@(AllowRowReorder && !IsEditing(item))"
                        @ondragstart="(e) => OnRowDragStart(e, rowIndex)"
                        @ondragstart:stopPropagation>
                        <span class="@DataGridStyles.RowDragIcon">⋮⋮</span>
                    </td>
                    @foreach (var column in Columns)
                    {
                        <td>
                            @if (IsEditing(item))
                            {
                                @column.EditTemplate(item)
                            }
                            else
                            {
                                @column.DisplayTemplate(item)
                            }
                        </td>
                    }
                    <td class="@DataGridStyles.ActionsCell">
                        @if (IsEditing(item))
                        {
                            <button class="@DataGridStyles.Btn @DataGridStyles.BtnSave" @onclick="() => SaveRow(item)">Save</button>
                            <button class="@DataGridStyles.Btn @DataGridStyles.BtnCancel" @onclick="() => CancelEdit(item)">Cancel</button>
                        }
                        else
                        {
                            <button class="@DataGridStyles.Btn @DataGridStyles.BtnEdit" @onclick="() => EditRow(item)">Edit</button>
                            <button class="@DataGridStyles.Btn @DataGridStyles.BtnDelete" @onclick="() => DeleteRow(item)">Delete</button>
                        }
                    </td>
                </tr>
                @if (IsEditing(item) && ValidationErrors.TryGetValue(item, out var validationError))
                {
                    <tr class="@DataGridStyles.ValidationRow">
                        <td colspan="@(Columns.Count + 2)" class="@DataGridStyles.ValidationCell">
                            <div class="@DataGridStyles.ValidationErrors">
                                @foreach (var error in validationError)
                                {
                                    <div class="@DataGridStyles.ValidationError">@error</div>
                                }
                            </div>
                        </td>
                    </tr>
                }
            }
        </tbody>
    </table>

    <button class="@DataGridStyles.Btn @DataGridStyles.BtnAdd" @onclick="AddNewRow">Add New Row</button>
</div>

@code {
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public List<TItem> Items { get; set; } = [];

    [Parameter]
    public List<GridColumn<TItem>> Columns { get; set; } = [];

    [Parameter]
    public Func<TItem>? CreateNewItem { get; set; }

    [Parameter]
    public Func<TItem, TItem>? CloneItem { get; set; }

    [Parameter]
    public Func<TItem, Task<ValidationResult>>? OnItemSaved { get; set; }

    [Parameter]
    public Func<TItem, Task<ValidationResult>>? OnItemDeleted { get; set; }

    [Parameter]
    public Func<TItem, Task<ValidationResult>>? OnItemAdded { get; set; }

    [Parameter]
    public bool AllowRowReorder { get; set; } = true;

    [Parameter]
    public string? OrderPropertyName { get; set; }

    private TItem? EditingItem { get; set; }
    private Dictionary<TItem, List<string>> ValidationErrors { get; set; } = new();
    private TItem? OriginalItem { get; set; }
    private string? CurrentSortColumn { get; set; }
    private bool IsSortAscending { get; set; } = true;
    private int? DraggedRowIndex { get; set; }
    private bool AddingNewRow { get; set; }
    private bool _isInitializing = false;

    protected override void OnInitialized()
    {
        if (ChildContent != null && Columns.Count == 0)
        {
            _isInitializing = true;
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender && _isInitializing)
        {
            _isInitializing = false;
            StateHasChanged();
        }
    }

    private bool IsEditing(TItem item)
    {
        return EditingItem == item;
    }

    private string GetRowClass(TItem item)
    {
        if (EditingItem == item)
        {
            return IsNewItem(item) ? $"{DataGridStyles.Editing} {DataGridStyles.NewRow}" : DataGridStyles.Editing;
        }

        return DataGridStyles.DataRow;
    }

    private bool IsNewItem(TItem item)
    {
        return OriginalItem == null && EditingItem == item;
    }

    private void EditRow(TItem item)
    {
        if (EditingItem != null && EditingItem != item)
        {
            CancelEdit(EditingItem);
        }

        if (CloneItem != null)
        {
            OriginalItem = CloneItem(item);
        }

        EditingItem = item;
        AddingNewRow = false;
    }

    private async Task<bool> SaveRow(TItem item)
    {
        ValidationErrors.Remove(item);

        ValidationResult? result = null;

        if (IsNewItem(item))
        {
            if (OnItemAdded != null)
            {
                result = await OnItemAdded(item);
            }
        }
        else
        {
            if (OnItemSaved != null)
            {
                result = await OnItemSaved(item);
            }
        }

        if (result is { IsValid: false })
        {
            ValidationErrors[item] = result.Errors;
            StateHasChanged();
            return false;
        }

        EditingItem = null;
        OriginalItem = null;
        AddingNewRow = false;

        return true;
    }

    private void CancelEdit(TItem item)
    {
        if (IsNewItem(item))
        {
            Items.Remove(item);
        }
        else if (OriginalItem != null)
        {
            CopyProperties(OriginalItem, item);
        }

        ValidationErrors.Remove(item);
        EditingItem = null;
        OriginalItem = null;
    }

    private async Task DeleteRow(TItem item)
    {
        ValidationResult? result = null;

        if (OnItemDeleted != null)
        {
            result = await OnItemDeleted(item);
        }

        if (result is { IsValid: false })
        {
            return;
        }

        Items.Remove(item);
    }

    private async Task AddNewRow()
    {
        if (EditingItem != null)
        {
            if (IsNewItem(EditingItem))
            {
                if (!await SaveRow(EditingItem))
                {
                    return;
                }
            }
            else
            {
                CancelEdit(EditingItem);    
            }
        }

        AddingNewRow = true;

        var newItem = CreateNewItem != null 
            ? CreateNewItem() 
            : new TItem();

        Items.Add(newItem);
        EditingItem = newItem;
    }

    private void SortByColumn(GridColumn<TItem> column)
    {
        if (AllowRowReorder || !column.Sortable || column.SortExpression == null)
        {
            return;
        }

        if (CurrentSortColumn == column.HeaderText)
        {
            IsSortAscending = !IsSortAscending;
        }
        else
        {
            CurrentSortColumn = column.HeaderText;
            IsSortAscending = true;
        }

        Items = IsSortAscending
            ? Items.OrderBy(column.SortExpression.Compile()).ToList()
            : Items.OrderByDescending(column.SortExpression.Compile()).ToList();
    }

    private string GetSortClass(GridColumn<TItem> column)
    {
        if (CurrentSortColumn == column.HeaderText)
        {
            return IsSortAscending ? DataGridStyles.SortAsc : DataGridStyles.SortDesc;
        }

        return string.Empty;
    }

    private static void CopyProperties(TItem source, TItem destination)
    {
        var properties = typeof(TItem).GetProperties()
            .Where(p => p is { CanRead: true, CanWrite: true });

        foreach (var property in properties)
        {
            var value = property.GetValue(source);
            property.SetValue(destination, value);
        }
    }

    private void OnRowDragStart(DragEventArgs e, int index)
    {
        DraggedRowIndex = index;
        e.DataTransfer.EffectAllowed = "move";
    }

    private void OnRowDrop(int targetIndex)
    {
        if (DraggedRowIndex.HasValue && DraggedRowIndex.Value != targetIndex)
        {
            var sourceIndex = DraggedRowIndex.Value;
            var draggedItem = Items[sourceIndex];
            Items.RemoveAt(sourceIndex);
            Items.Insert(targetIndex, draggedItem);

            UpdateOrderProperty(sourceIndex, targetIndex);

            StateHasChanged();
        }
        DraggedRowIndex = null;
    }

    private void UpdateOrderProperty(int sourceIndex, int targetIndex)
    {
        if (string.IsNullOrEmpty(OrderPropertyName)) return;

        var property = typeof(TItem).GetProperty(OrderPropertyName);
        if (property == null || !property.CanWrite) return;

        var startIndex = Math.Min(sourceIndex, targetIndex);
        var endIndex = Math.Max(sourceIndex, targetIndex);

        for (var index = startIndex; index <= endIndex; index++)
        {
            var item = Items[index];
            var value = Convert.ChangeType(index, property.PropertyType);
            property.SetValue(item, value);
        }
    }

    public void AddColumn(GridColumn<TItem> column)
    {
        Columns.Add(column);

        // Only trigger state change if not initializing (code-behind mode)
        if (!_isInitializing)
        {
            InvokeAsync(StateHasChanged);
        }
    }
}
