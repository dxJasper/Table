@typeparam TItem where TItem : class, new()
@using System.Reflection
@using Table.Models
@using Table.Components
@implements IDisposable

<CascadingValue Value="this">
    @ChildContent
</CascadingValue>

<div class="@DataGridStyles.GridContainer">
    <table class="@DataGridStyles.CustomDatagrid">
        <thead>
            <tr>
                <th class="@DataGridStyles.RowDragHeader @(AllowRowReorder && !ReadOnly ? string.Empty : DataGridStyles.Hidden)"></th>
                @foreach (var column in Columns)
                {
                    var isSortable = !AllowRowReorder && column.Sortable;
                    <th class="@(isSortable ? DataGridStyles.Sortable : string.Empty)"
                        @onclick="() => SortByColumn(column)">
                        @column.HeaderText
                        @if (isSortable)
                        {
                            <span class="@DataGridStyles.SortIcon @GetSortClass(column)"></span>
                        }
                    </th>
                }
                @if (!ReadOnly)
                {
                    <th class="@DataGridStyles.ActionsHeader">Actions</th>
                }
            </tr>
        </thead>
        <tbody>
            @for (var index = 0; index < Items.Count; index++)
            {
                var rowIndex = index;
                var item = Items[rowIndex];
                var isEditing = IsEditing(item);
                var validationErrors = ValidationErrors.TryGetValue(item, out var errors) ? errors : null;

                <DataGridRow TItem="TItem"
                             Item="item"
                             Columns="Columns"
                             IsEditing="isEditing"
                             IsNewRow="IsNewItem(item)"
                             IsDragging="DraggedRowIndex == rowIndex"
                             AllowRowReorder="AllowRowReorder"
                             ReadOnly="ReadOnly"
                             ValidationErrors="validationErrors"
                             OnEdit="() => EditRow(item)"
                             OnSave="() => SaveRow(item)"
                             OnCancel="() => CancelEdit(item)"
                             OnDelete="() => DeleteRow(item)"
                             OnDragStart="(e) => OnRowDragStart(e, rowIndex)"
                             OnDrop="() => OnRowDrop(rowIndex)"
                             @key="item" />
            }
        </tbody>
    </table>

    @if (!ReadOnly)
    {
        <button class="@DataGridStyles.Btn @DataGridStyles.BtnAdd" @onclick="AddNewRow">Add New Row</button>
    }
</div>

@code {
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public List<TItem> Items { get; set; } = [];

    [Parameter]
    public List<GridColumn<TItem>> Columns { get; set; } = [];

    [Parameter]
    public Func<TItem>? CreateNewItem { get; set; }

    [Parameter]
    public Func<TItem, Task<ValidationResult>>? OnItemSaved { get; set; }

    [Parameter]
    public Func<TItem, Task<ValidationResult>>? OnItemDeleted { get; set; }

    [Parameter]
    public Func<TItem, Task<ValidationResult>>? OnItemAdded { get; set; }

    [Parameter]
    public bool AllowRowReorder { get; set; } = true;

    [Parameter]
    public string? OrderPropertyName { get; set; }

    [Parameter]
    public bool ReadOnly { get; set; } = false;

    private TItem? EditingItem { get; set; }
    private Dictionary<TItem, List<string>> ValidationErrors { get; set; } = new();
    private TItem? OriginalItem { get; set; }
    private string? CurrentSortColumn { get; set; }
    private bool IsSortAscending { get; set; } = true;
    private int? DraggedRowIndex { get; set; }
    private bool AddingNewRow { get; set; }
    private bool _isInitializing = false;

    // Cache reflection results for performance
    private static readonly Dictionary<Type, PropertyInfo[]> _propertyCache = new();
    private PropertyInfo? _orderProperty;
    private bool _orderPropertyResolved;

    // Cache compiled sort expressions
    private readonly Dictionary<string, Func<TItem, object>> _compiledSortExpressions = new();

    protected override void OnInitialized()
    {
        if (ChildContent != null && Columns.Count == 0)
        {
            _isInitializing = true;
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender && _isInitializing)
        {
            _isInitializing = false;
            StateHasChanged();
        }
    }

    protected override bool ShouldRender()
    {
        // Always render to ensure child components receive parameter updates
        // The child DataGridRow components handle their own render optimization
        return true;
    }

    private bool IsEditing(TItem item)
    {
        return EditingItem == item;
    }

    private bool IsNewItem(TItem item)
    {
        return OriginalItem == null && EditingItem == item;
    }

    private void EditRow(TItem item)
    {
        if (EditingItem != null && EditingItem != item)
        {
            CancelEdit(EditingItem);
        }

        // Clone the item using reflection
        OriginalItem = CloneItemReflection(item);

        EditingItem = item;
        AddingNewRow = false;
    }

    private async Task<bool> SaveRow(TItem item)
    {
        ValidationErrors.Remove(item);

        ValidationResult? result = null;

        if (IsNewItem(item))
        {
            if (OnItemAdded != null)
            {
                result = await OnItemAdded(item);
            }
        }
        else
        {
            if (OnItemSaved != null)
            {
                result = await OnItemSaved(item);
            }
        }

        if (result is { IsValid: false })
        {
            ValidationErrors[item] = result.Errors;
            StateHasChanged();
            return false;
        }

        EditingItem = null;
        OriginalItem = null;
        AddingNewRow = false;

        return true;
    }

    private void CancelEdit(TItem item)
    {
        if (IsNewItem(item))
        {
            Items.Remove(item);
        }
        else if (OriginalItem != null)
        {
            CopyProperties(OriginalItem, item);
        }

        ValidationErrors.Remove(item);
        EditingItem = null;
        OriginalItem = null;
    }

    private async Task DeleteRow(TItem item)
    {
        ValidationResult? result = null;

        if (OnItemDeleted != null)
        {
            result = await OnItemDeleted(item);
        }

        if (result is { IsValid: false })
        {
            return;
        }

        Items.Remove(item);
    }

    private async Task AddNewRow()
    {
        if (EditingItem != null)
        {
            if (IsNewItem(EditingItem))
            {
                if (!await SaveRow(EditingItem))
                {
                    return;
                }
            }
            else
            {
                CancelEdit(EditingItem);    
            }
        }

        AddingNewRow = true;

        var newItem = CreateNewItem != null 
            ? CreateNewItem() 
            : new TItem();

        Items.Add(newItem);
        EditingItem = newItem;
    }

    private void SortByColumn(GridColumn<TItem> column)
    {
        if (AllowRowReorder || !column.Sortable || column.SortExpression == null)
        {
            return;
        }

        if (CurrentSortColumn == column.HeaderText)
        {
            IsSortAscending = !IsSortAscending;
        }
        else
        {
            CurrentSortColumn = column.HeaderText;
            IsSortAscending = true;
        }

        // Cache the compiled expression to avoid recompiling on every sort
        if (!_compiledSortExpressions.TryGetValue(column.HeaderText, out var compiledExpression))
        {
            compiledExpression = column.SortExpression.Compile();
            _compiledSortExpressions[column.HeaderText] = compiledExpression;
        }

        Items = IsSortAscending
            ? Items.OrderBy(compiledExpression).ToList()
            : Items.OrderByDescending(compiledExpression).ToList();
    }

    private string GetSortClass(GridColumn<TItem> column)
    {
        if (CurrentSortColumn == column.HeaderText)
        {
            return IsSortAscending ? DataGridStyles.SortAsc : DataGridStyles.SortDesc;
        }

        return string.Empty;
    }

    private static void CopyProperties(TItem source, TItem destination)
    {
        var properties = GetCachedProperties();

        foreach (var property in properties)
        {
            var value = property.GetValue(source);
            property.SetValue(destination, value);
        }
    }

    private static PropertyInfo[] GetCachedProperties()
    {
        var type = typeof(TItem);

        if (!_propertyCache.TryGetValue(type, out var properties))
        {
            properties = type.GetProperties()
                .Where(p => p is { CanRead: true, CanWrite: true })
                .ToArray();

            _propertyCache[type] = properties;
        }

        return properties;
    }

    private static TItem CloneItemReflection(TItem source)
    {
        var clone = new TItem();
        CopyProperties(source, clone);
        return clone;
    }

    private void OnRowDragStart(DragEventArgs e, int index)
    {
        DraggedRowIndex = index;
        e.DataTransfer.EffectAllowed = "move";
    }

    private void OnRowDrop(int targetIndex)
    {
        if (DraggedRowIndex.HasValue && DraggedRowIndex.Value != targetIndex)
        {
            var sourceIndex = DraggedRowIndex.Value;
            var draggedItem = Items[sourceIndex];
            Items.RemoveAt(sourceIndex);
            Items.Insert(targetIndex, draggedItem);

            UpdateOrderProperty(sourceIndex, targetIndex);

            StateHasChanged();
        }
        DraggedRowIndex = null;
    }

    private void UpdateOrderProperty(int sourceIndex, int targetIndex)
    {
        if (string.IsNullOrEmpty(OrderPropertyName)) return;

        // Cache the property lookup
        if (!_orderPropertyResolved)
        {
            _orderProperty = typeof(TItem).GetProperty(OrderPropertyName);
            _orderPropertyResolved = true;
        }

        if (_orderProperty == null || !_orderProperty.CanWrite) return;

        var startIndex = Math.Min(sourceIndex, targetIndex);
        var endIndex = Math.Max(sourceIndex, targetIndex);

        for (var index = startIndex; index <= endIndex; index++)
        {
            var item = Items[index];
            var value = Convert.ChangeType(index, _orderProperty.PropertyType);
            _orderProperty.SetValue(item, value);
        }
    }

    public void AddColumn(GridColumn<TItem> column)
    {
        Columns.Add(column);

        // Only trigger state change if not initializing (code-behind mode)
        if (!_isInitializing)
        {
            InvokeAsync(StateHasChanged);
        }
    }

    public void Dispose()
    {
        // Clear caches to free memory
        _compiledSortExpressions?.Clear();
        ValidationErrors?.Clear();

        // Clear item references
        EditingItem = null;
        OriginalItem = null;
        Items?.Clear();
        Columns?.Clear();

        // Note: Static cache (_propertyCache) is shared across instances
        // and should not be cleared here
    }
}
